---
title: "Compare Encode Features"
author: "James Galante"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

# Save Image
```{r}
# Saving image for debugging
save.image(paste0("RDA_objects/compare_encode_features.rda"))
message("Saved Image")
# stop("Manually Stopped Program after Saving Image")
```

# Imports
```{r}
suppressPackageStartupMessages({
  library(tidyverse)
})
```

```{r}
# Load in the snakemake inputs
expt_pred_merged_annot_files <- lapply(snakemake@input, read_tsv)
names(expt_pred_merged_annot_files) <- c("validation", "training", "unfiltered_k562_dc_tap")
```

# Training vs Validation
## Visualize the distributions of all pairs
```{r}
val <- expt_pred_merged_annot_files[["validation"]]
train <- expt_pred_merged_annot_files[["training"]]
```

```{r}
# Get feature columns
feature_cols <- grep("\\.Feature$", colnames(val), value = TRUE)

plot_feature <- function(train_data, val_data, feature_name) {
  # Combine data for plotting
  plot_data <- bind_rows(
    mutate(train_data, Dataset = "Training"),
    mutate(val_data, Dataset = "Validation")
  )
  
  if (feature_name == "ubiquitousExpressedGene.Feature") {
    # For ubiquitous gene feature - use proportions by Dataset and Regulated status
    counts <- plot_data %>%
      group_by(Dataset, Regulated) %>%
      summarise(
        total = n(),
        true_count = sum(.data[[feature_name]], na.rm = TRUE),
        proportion = true_count / total,
        .groups = 'drop'
      )
    
    p <- ggplot(counts, aes(x = interaction(Dataset, Regulated), y = proportion, fill = Dataset)) +
      geom_bar(stat = "identity") +
      scale_fill_manual(values = c("Training" = "#1f77b4", "Validation" = "#2ca02c")) +
      theme_minimal() +
      labs(title = feature_name,
           x = "Dataset and Regulation Status",
           y = "Proportion of Dataset") +
      theme(axis.text.x = element_text(angle = 45, hjust = 1))
  
  } else if (feature_name %in% c("3DContact.Feature", "ABC.Score.Feature")) {
    # For 3D contact and ABC features - use log10 scale
    p <- ggplot(plot_data, aes(x = interaction(Dataset, Regulated), y = .data[[feature_name]])) +
      geom_boxplot(aes(color = Dataset), alpha = 0.5, outlier.shape = NA) +
      geom_jitter(aes(color = category), alpha = 1, width = 0.2, size = 0.5) +
      scale_y_log10() +
      theme_minimal() +
      labs(title = feature_name,
           x = "Dataset and Regulation Status",
           y = "Value (log10 scale)") +
      theme(legend.position = "right",
            axis.text.x = element_text(angle = 45, hjust = 1))
  
  } else if (is.numeric(plot_data[[feature_name]])) {
    # For other numeric features
    p <- ggplot(plot_data, aes(x = interaction(Dataset, Regulated), y = .data[[feature_name]])) +
      geom_boxplot(aes(color = Dataset), alpha = 0.5, outlier.shape = NA) +
      geom_jitter(aes(color = category), alpha = 1, width = 0.2, size = 0.5) +
      theme_minimal() +
      labs(title = feature_name,
           x = "Dataset and Regulation Status",
           y = "Value") +
      theme(legend.position = "right",
            axis.text.x = element_text(angle = 45, hjust = 1))
    
    # Add log scale if data spans multiple orders of magnitude
    if (diff(range(plot_data[[feature_name]], na.rm = TRUE)) > 1000) {
      p <- p + scale_y_log10()
    }
  }
  
  return(p)
}

# Create all plots
plots <- lapply(feature_cols, function(col) plot_feature(train, val, col))

# Print feature types for reference
feature_types <- sapply(feature_cols, function(col) class(val[[col]]))
print("Feature Types:")
print(feature_types)

# Print all plots
for(p in plots) {
  print(p)
}
```



```{r, message=FALSE}
plot_feature <- function(train_data, val_data, feature_name) {
  if (!is.numeric(train_data[[feature_name]])) {
    return(NULL)  # Skip non-numeric features
  }
  
  # Prepare data for density plots
  train_plot <- train_data %>% 
    mutate(
      Dataset = "Training",
      Value = .data[[feature_name]]
    )
  
  val_plot <- val_data %>% 
    mutate(
      Dataset = "Validation",
      Value = .data[[feature_name]]
    )
  
  plot_data <- bind_rows(train_plot, val_plot)
  
  # Create density plot
  p <- ggplot(plot_data, aes(x = Value, fill = Regulated)) +
    geom_density(alpha = 0.5) +
    facet_wrap(~Dataset, ncol = 1, scales = "free_y") +
    theme_minimal() +
    scale_fill_manual(values = c("FALSE" = "#1f77b4", "TRUE" = "#2ca02c")) +
    labs(title = feature_name,
         x = "Value",
         y = "Density")
  
  # Add log scale if needed
  if (feature_name %in% c("3DContact.Feature", "ABC.Score.Feature") || 
      diff(range(plot_data$Value, na.rm = TRUE)) > 1000) {
    p <- p + scale_x_log10()
  }
  
  return(p)
}

# Create and print plots
plots <- lapply(feature_cols, function(col) plot_feature(train, val, col))
plots <- plots[!sapply(plots, is.null)]  # Remove NULL plots (non-numeric features)

for(p in plots) {
  print(p)
}
```


```{r}
plot_feature <- function(train_data, val_data, feature_name) {
  if (!is.numeric(train_data[[feature_name]])) {
    return(NULL)
  }
  
  # Prepare data
  train_plot <- train_data %>% 
    mutate(
      Dataset = "Training",
      Value = .data[[feature_name]]
    )
  
  val_plot <- val_data %>% 
    mutate(
      Dataset = "Validation",
      Value = .data[[feature_name]]
    )
  
  plot_data <- bind_rows(train_plot, val_plot)
  
  # Create base plot with lighter overall distributions
  p <- ggplot() +
    # Base distributions (lighter)
    geom_density(data = plot_data, 
                aes(x = Value, fill = Regulated),
                alpha = 0.3) +  # Made more transparent
    # Individual category distributions
    geom_density(data = plot_data,
                aes(x = Value, color = category),
                alpha = 0.7,
                linewidth = 0.5) +
    facet_wrap(~Dataset, ncol = 1, scales = "free_y") +
    theme_minimal() +
    scale_fill_manual(values = c("FALSE" = "#1f77b4", "TRUE" = "#2ca02c"),
                     name = "Regulated Status") +
    labs(title = feature_name,
         x = "Value",
         y = "Density",
         color = "Category")
  
  # Add log scale if needed
  if (feature_name %in% c("3DContact.Feature", "ABC.Score.Feature") || 
      diff(range(plot_data$Value, na.rm = TRUE)) > 1000) {
    p <- p + scale_x_log10()
  }
  
  return(p)
}

# Create and print plots
plots <- lapply(feature_cols, function(col) plot_feature(train, val, col))
plots <- plots[!sapply(plots, is.null)]

for(p in plots) {
  print(p)
}
```


```{r}
plot_feature_boxes <- function(train_data, val_data, feature_name) {
 if (!is.numeric(train_data[[feature_name]]) || feature_name == "ubiquitousExpressedGene.Feature") {
   return(NULL)
 }
 
 # Prepare data
 train_plot <- train_data %>% 
   mutate(
     Dataset = "Training",
     Value = .data[[feature_name]]
   ) %>%
   filter(!is.infinite(Value))
 
 val_plot <- val_data %>% 
   mutate(
     Dataset = "Validation",
     Value = .data[[feature_name]]
   ) %>%
   filter(!is.infinite(Value))
 
 plot_data <- bind_rows(train_plot, val_plot)
 
  # Create combined dataset with ordered groups
  all_data <- bind_rows(
    plot_data %>% mutate(Group = "1_Total"),
    plot_data %>% mutate(Group = paste("2_Regulated =", Regulated)),
    plot_data %>% mutate(Group = category)  # Remove the "3" prefix
  ) %>%
    mutate(Group = sub("^[12]_", "", Group)) %>%  # Only remove 1_ and 2_ prefixes
    filter(!is.na(Value))
 
 # Create ordered factor levels separately for each dataset
 all_data <- all_data %>%
   group_by(Dataset) %>%
   mutate(Group = factor(Group, 
                        levels = c("Total", 
                                 "Regulated = FALSE", 
                                 "Regulated = TRUE",
                                 unique(sort(Group[!Group %in% c("Total", 
                                                               "Regulated = FALSE", 
                                                               "Regulated = TRUE")])))))
 
 # Create color vector - white/black for categories
 color_vector <- c(
   "Total" = "purple",
   "Regulated = FALSE" = "blue",
   "Regulated = TRUE" = "green",
   setNames(rep("black", length(unique(all_data$Group)) - 3), 
           unique(all_data$Group)[!unique(all_data$Group) %in% c("Total", "Regulated = FALSE", "Regulated = TRUE")])
 )
 
 # Determine if log scale is needed
 needs_log <- feature_name %in% c("3DContact.Feature", "ABC.Score.Feature") || 
              (diff(range(all_data$Value[all_data$Value > 0], na.rm = TRUE)) > 1000)
 
 # Create plot
 p <- ggplot(all_data, aes(x = Value, y = Group, fill = Group)) +
   geom_boxplot(outlier.shape = NA) +
   # geom_jitter(alpha = 0.1, height = 0.2, size = 0.5, color = "grey50") +
   facet_grid(Dataset ~ ., scales = "free_y", space = "free_y") +
   scale_fill_manual(values = color_vector) +
   theme_minimal() +
   theme(legend.position = "none") +
   labs(title = feature_name,
        x = "Value",
        y = NULL)
 
 # Add log scale if needed and data is positive
 if (needs_log && min(all_data$Value, na.rm = TRUE) > 0) {
   p <- p + scale_x_log10()
 }
 
 return(p)
}

# Create and print plots
box_plots <- lapply(feature_cols, function(col) plot_feature_boxes(train, val, col))
box_plots <- box_plots[!sapply(box_plots, is.null)]

for(p in box_plots) {
 print(p)
}
```


a good thing to visualize with the plots below is for every sample that's predicted as True, what the values are for that feature

```{r}
plot_feature_boxes <- function(train_data, val_data, feature_name) {
  # Initial checks
  if (!is.numeric(train_data[[feature_name]]) || feature_name == "ubiquitousExpressedGene.Feature") {
    return(NULL)
  }
  
  # Create dataset for total comparisons
  total_data <- bind_rows(
    tibble(Value = train_data[[feature_name]], Dataset = "Training", Group = "Total"),
    tibble(Value = val_data[[feature_name]], Dataset = "Validation", Group = "Total")
  )
  
  # Create dataset for regulated comparisons
  regulated_data <- bind_rows(
    tibble(
      Value = train_data[[feature_name]], 
      Dataset = "Training", 
      Group = paste("Regulated =", train_data$Regulated)
    ),
    tibble(
      Value = val_data[[feature_name]], 
      Dataset = "Validation", 
      Group = paste("Regulated =", val_data$Regulated)
    )
  )
  
  # Combine and clean data
  all_data <- bind_rows(total_data, regulated_data) %>%
    filter(!is.na(Value), !is.infinite(Value), 
           Group %in% c("Total", "Regulated = TRUE", "Regulated = FALSE"))
  
  # Order groups
  all_data$Group <- factor(all_data$Group, 
                          levels = c("Total", "Regulated = FALSE", "Regulated = TRUE"))
  
  # Define comparisons for significance testing
  my_comparisons <- list(c("Training", "Validation"))
  
  # Create plot
  p <- ggplot(all_data, aes(x = Group, y = Value, fill = Dataset)) +
    geom_boxplot(position = position_dodge(0.8), outlier.shape = NA) +
    theme_classic() +
    labs(title = feature_name,
         x = NULL,
         y = "Value") +
    scale_fill_brewer(palette = "Set1")
  
  # Add log scale if needed
  if (feature_name %in% c("3DContact.Feature", "ABC.Score.Feature") || 
      diff(range(all_data$Value, na.rm = TRUE)) > 1000) {
    p <- p + scale_y_log10()
  }
  
  return(p)
}

# Test the function
plots <- lapply(feature_cols, function(col) plot_feature_boxes(train, val, col))
plots <- plots[!sapply(plots, is.null)]

for(p in plots) {
 print(p)
}
```



```{r}
library(patchwork)

plot_total_comparisons <- function(train_data, val_data, feature_name) {
  if (!is.numeric(train_data[[feature_name]]) || feature_name == "ubiquitousExpressedGene.Feature") {
    return(NULL)
  }
  
  # Create total comparison data
  total_data <- bind_rows(
    tibble(Value = train_data[[feature_name]], Dataset = "Training"),
    tibble(Value = val_data[[feature_name]], Dataset = "Validation")
  ) %>%
    filter(!is.na(Value), !is.infinite(Value))
  
  # Calculate range to adjust spacing
  value_range <- range(total_data$Value, na.rm = TRUE)
  max_val <- max(total_data$Value, na.rm = TRUE)
  
  # Create plot
  p <- ggplot(total_data, aes(x = Dataset, y = Value, fill = Dataset)) +
    geom_boxplot(outlier.shape = NA) +
    theme_classic() +
    labs(title = str_remove(feature_name, "\\.Feature$"),  # Remove .Feature suffix
         x = NULL,
         y = "Value") +
    scale_fill_brewer(palette = "Set1") +
    theme(legend.position = "none",
          plot.title = element_text(size = 8),
          axis.text = element_text(size = 7),
          axis.title = element_text(size = 8))
  
  # Add log scale if needed
  if (feature_name %in% c("3DContact.Feature", "ABC.Score.Feature") || 
      diff(value_range) > 1000) {
    p <- p + scale_y_log10()
  }
  
  return(p)
}

# Create plots for each feature
total_plots <- lapply(feature_cols, function(col) plot_total_comparisons(train, val, col))
total_plots <- total_plots[!sapply(total_plots, is.null)]

# Combine plots using patchwork
combined_plot <- wrap_plots(total_plots, ncol = 3) + 
  plot_annotation(
    title = 'Feature Comparisons between Training and Validation Sets',
    theme = theme(plot.title = element_text(size = 12, hjust = 0.5))
  )

# Print combined plot
print(combined_plot)

# Save if needed
# ggsave("combined_features.pdf", combined_plot, width = 12, height = 8)
```

